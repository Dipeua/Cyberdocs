Le XSS basé sur le DOM (également appelé DOM XSS) survient lorsqu'une application contient du JavaScript côté client qui traite les données d'une source non fiable de manière dangereuse, généralement en réécrivant les données dans le DOM.

Dans l'exemple suivant, une application utilise du JavaScript pour lire la valeur d'un champ de saisie et écrire cette valeur dans un élément du code HTML :

```js
var search = document.getElementById('search').value; 
var results = document.getElementById('results'); 

results.innerHTML = 'You searched for: ' + search;
```

Si l'attaquant peut contrôler la valeur du champ de saisie, il peut facilement construire une valeur malveillante qui provoque l'exécution de son propre script :

```html
You searched for: <img src=1 onerror='/* Bad stuff here... */'>
```

---

Les vulnérabilités basées sur le DOM surviennent lorsqu'un site web contient du JavaScript qui prend une valeur contrôlable par l'attaquant, appelée `source`, et la transmet à une fonction dangereuse, appelée `récepteur ou puit (sink)`.

### Sources communes

Voici quelques sources typiques qui peuvent être utilisées pour exploiter diverses vulnérabilités de flux contaminé :

```js
document.URL
document.documentURI
document.URLUnencoded
document.baseURI
location
document.cookie
document.referrer
window.name
history.pushState
history.replaceState
localStorage
sessionStorage
IndexedDB (mozIndexedDB, webkitIndexedDB, msIndexedDB)
Database
```

### Quels puits peuvent conduire à des vulnérabilités DOM-XSS ?

Voici quelques-uns des principaux puits pouvant conduire à des vulnérabilités DOM-XSS :

```js
document.write()
document.writeln()
document.domain
element.innerHTML
element.outerHTML
element.insertAdjacentHTML
element.oneventa
```

Les fonctions jQuery suivantes sont également des puits qui peuvent conduire à des vulnérabilités DOM-XSS :

```js
add()
after()
append()
animate()
insertAfter()
insertBefore()
before()
html()
prepend()
replaceAll()
replaceWith()
wrap()
wrapInner()
wrapAll()
has()
constructor()
init()
index()
jQuery.parseHTML()
$.parseHTML()
```

## Tester les XSS basés sur DOM

**Tester les récepteurs HTML** 

Pour tester les XSS DOM dans un récepteur HTML, insérez une chaîne alphanumérique aléatoire dans la source (par exemple, `location.search`), puis utilisez les outils de développement pour inspecter le code HTML et trouver où elle apparaît. Notez que l'option « Afficher la source » du navigateur ne fonctionne pas pour les tests XSS DOM, car elle ne prend pas en compte les modifications apportées au code HTML par JavaScript. Dans les outils de développement de Chrome, vous pouvez utiliser `Control+F`  pour rechercher votre chaîne dans le DOM.

Pour chaque emplacement de votre chaîne dans le DOM, vous devez identifier le contexte. En fonction de ce contexte, vous devez affiner votre saisie pour voir comment elle est traitée. Par exemple, si votre chaîne apparaît dans un attribut entre guillemets, essayez d'insérer des guillemets dans votre chaîne pour voir si vous pouvez sortir de cet attribut.

> Si vos données sont encodées en URL avant d'être traitées, une attaque XSS a peu de chances de réussir.

**Tester les puits d'exécution JavaScript**

Tester les récepteurs d'exécution JavaScript pour les XSS basés sur DOM est un peu plus complexe. Avec ces récepteurs, votre entrée n'apparaît pas forcément dans le DOM ; vous ne pouvez donc pas la rechercher. Vous devrez donc utiliser le débogueur JavaScript pour déterminer si et comment votre entrée est envoyée à un récepteur.

Pour chaque source potentielle, telle que `location`, vous devez d'abord identifier les cas dans le code JavaScript de la page où la source est référencée.

Lorsque vous trouvez un récepteur auquel sont affectées des données provenant de la source, vous pouvez utiliser le débogueur pour inspecter la valeur en survolant la variable afin d'afficher sa valeur avant son envoi au récepteur. Ensuite, comme pour les récepteurs HTML, vous devez affiner votre saisie pour déterminer si vous pouvez réussir une attaque XSS.

**Test de DOM XSS avec DOM Invader**

Identifier et exploiter les attaques DOM XSS peut s'avérer fastidieux, nécessitant souvent de parcourir manuellement du JavaScript complexe et minifié. Si vous utilisez le navigateur de Burp, vous pouvez toutefois profiter de son extension DOM Invader intégrée, qui effectue une grande partie du travail à votre place.

# Exploiter DOM XSS avec différentes sources et récepteurs

#### DOM XSS dans jQuery

Si vous utilisez une bibliothèque JavaScript telle que jQuery, soyez attentif aux récepteurs susceptibles de modifier les éléments DOM de la page comme `attr()`.

Vous pouvez exploiter ce problème en modifiant l'URL afin que la source contienne une URL JavaScript malveillante.

```js
?returnUrl=javascript:alert(document.domain)
```

Un autre puits potentiel à surveiller est la fonction `$()` de sélection de jQuery, qui peut être utilisée pour injecter des objets malveillants dans le DOM.

similaire à celui-ci :

```js
$(window).on('hashchange', function() {
	var element = $(location.hash);
	element[0].scrollIntoView();
});
```

Pour exploiter cette vulnérabilité classique, vous devrez trouver un moyen de déclencher un événement  `hashchange` sans interaction de l'utilisateur. L'une des méthodes les plus simples consiste à diffuser votre exploit via iframe :

```html
<iframe src="https://vulnerable-website.com#" onload="this.src+='<img src=1 onerror=alert(1)>'">
```

Dans cet exemple, l'attribut `src` pointe vers la page vulnérable avec une valeur de hachage vide. Lors du chargement `iframe`, un vecteur XSS est ajouté à la valeur de hachage, ce qui déclenche l' `hashchange`événement.
#### DOM XSS dans AngularJS

Si un framework comme AngularJS est utilisé, il peut être possible d'exécuter du JavaScript sans chevrons ni événements

Lorsqu'un site utilise l'attribut `ng-app` sur un élément HTML, celui-ci est traité par AngularJS.

Dans ce cas, AngularJS exécute le JavaScript entre des accolades doubles, qui peuvent apparaître directement dans le code HTML ou à l'intérieur des attributs.

```js
{{$on.constructor('alert(1)')()}}
```

