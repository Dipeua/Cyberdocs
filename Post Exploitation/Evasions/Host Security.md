# Antivirus

Enumérer les logiciels AV:

```c
wmic /namespace:\\root\securitycenter2 path antivirusproduct
```

```sh
Get-CimInstance -Namespace root/SecurityCenter2 -ClassName AntivirusProduct
```

---
# MS Defender

Vérifier  l'état du service de Windows Defender :

```c
Get-Service WinDefend
```

Obtenir l'état actuel de Windows Defender nous indique s'il est activé ou non : 

```c
Get-MpComputerStatus | select RealTimeProtectionEnabled
```

Fournir des détails sur les menaces détectées à l'aide de MS Defender

```sh
Get-MpThreat -ThrottleLimit 1
```

---
# Firewall 

Afficher les status du pare-feu : 

```c
Get-NetFirewallProfile | Format-Table Name, Enabled
```

Avec des privilèges d'administrateur, nous pouvons désactiver un ou plusieurs profils de pare-feu

```sh
Set-NetFirewallProfile -Profile Domain, Public, Private -Enabled False

Get-NetFirewallProfile | Format-Table Name, Enabled
```

Avec des privilèges d'administrateur on peut  également apprendre et vérifier les règles actuelles  du pare-feu , qu'elles autorisent ou refusent le pare-feu.

```c
Get-NetFirewallRule | select DisplayName, Enabled, Description
```

Connaitre ce que le pare-feu bloque comme connexion entrante en effectuant des tests sur des ports :

>  Supposons que nous sachions qu'un pare-feu est en place et que nous devons tester la connexion entrante sans outils supplémentaires, nous pouvons alors procéder comme suit


```sh
Test-NetConnection -ComputerName 127.0.0.1 -Port 80

(New-Object System.Net.Sockets.TcpClient("127.0.0.1", "445")).Connected
# True is : la connexion entrante sur le port 80 est ouverte et autorisée dans le pare-feu
```

> On peut également tester des cibles distantes dans le même réseau ou nom de domaine en spécifiant dans l'argument  `-ComputerName` pour `Test-NetConnection` .

---
# Sysmon

Obtenir une liste des journaux d'événements disponibles sur la machine locale : 

```sh
Get-EventLog -List
```

Détecter si sysmon est disponible ou non sur la machine victime : 

```c
Get-Process | Where-Object { $_.ProcessName -eq "Sysmon" }

Get-CimInstance win32_service -Filter "Description = 'System Monitor service'"

reg query HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\WINEVT\Channels\Microsoft-Windows-Sysmon/Operational
```

Une fois sysmon détecté, nous pouvons essayer de trouver son fichier de configuration pour comprendre ce que les administrateurs système surveillent.

```c
findstr /si '<ProcessCreate onmatch="exclude">' C:\tools\*
```

---
# EDR 

Nous pouvons utiliser des scripts pour énumérer les produits de sécurité au sein de la machine, tels que  [Invoke-EDRChecker](https://github.com/PwnDexter/Invoke-EDRChecker)  et [SharpEDRChecker](https://github.com/PwnDexter/SharpEDRChecker) .
